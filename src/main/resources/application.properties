
server.servlet.context-path=/api
server.port=8081


server.ssl.key-store=classpath:stores/keystore.p12
server.ssl.key-store-password=pass123
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=payment_concentrator

# server.ssl.trust-store=classpath:stores/truststore.p12
# server.ssl.trust-store-password=pass456
# server.ssl.trust-store-type=PKCS12

server.ssl.protocol=TLS
server.ssl.enabled-protocols=TLSv1.2
server.ssl.ciphers=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
# Za definisanje ovoga, treba prethodno iskoristi kod u PkiApplication klasi, koja izlistava sve podrzane
# chipers u Javi instaliranoj na nasem racunaru
# Kod je pronadjen na: https://stackoverflow.com/questions/48934210/java-ssl-error-cannot-support-tls-ecdhe-rsa-with-aes-256-gcm-sha384
server.ssl.client-auth=want
# for two way authentication, use value: need




#Spring DataSource
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:mem:myDb;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.username=sa
spring.datasource.password=
#Ukljucivanje konzole
spring.h2.console.enabled=true
#Putanja na kojoj ce konzola biti dostupna
spring.h2.console.path=/h2-console
#korisno ako je konekcija dugo u idle stanju
spring.datasource.testWhileIdle = true
spring.datasource.validationQuery = SELECT 1
#JPA-Hibernate - prikazuje SQL upite
spring.jpa.show-sql = true

#kreira tabele na osnovu anotacija @Entity i kada aplikacija zavrsi sa radom, dropuje ih
spring.jpa.hibernate.ddl-auto = create-drop
#bira najbolje konvencije imenovanja za tabele i polja u bazi
spring.jpa.hibernate.naming-strategy = org.hibernate.cfg.ImprovedNamingStrategy
#optimizacija za h2 upite
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect
#konekcija na bazu je jdbc:h2:mem:myDb